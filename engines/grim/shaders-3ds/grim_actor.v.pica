; actor shader for Grim Fandango in SCUMMVM

; ORIGINAL GLSL CODE
;	const float CONSTANT_ATTENUATION = 1.0;
;	const float LINEAR_ATTENUATION = 0.0;
;	const float QUADRATIC_ATTENUATION = 1.0;
;
;	in vec3 position;
;	in vec2 texcoord;
;	in vec4 color;
;	in vec3 normal;
;
;	uniform highp mat4 modelMatrix;
;	uniform highp mat4 viewMatrix;
;	uniform highp mat4 projMatrix;
;	uniform highp mat4 extraMatrix;
;	uniform UBOOL textured;
;	uniform UBOOL lightsEnabled;
;	uniform highp vec2 texScale;
;
;	struct shadow_info {
;		UBOOL _active;
;		vec3 _color;
;		vec3 _light;
;		vec3 _point;
;		vec3 _normal;
;	};
;
;	uniform shadow_info shadow;
;
;	out vec2 Texcoord;
;	out vec4 Color;
;
;	void main() {
;		vec4 pos = modelMatrix * extraMatrix * vec4(position, 1.0);
;
;		// See http://en.wikipedia.org/wiki/Line-plane_intersection
;		if (UBOOL_TEST(shadow._active)) {
;			pos /= pos.w;
;			vec3 l = pos.xyz - shadow._light;
;			float d = dot(shadow._point - shadow._light, shadow._normal) / dot(l, shadow._normal);
;			vec3 p = shadow._light + d * l;
;			pos = vec4(p, 1.0);
;		}
;
;		vec4 positionView = viewMatrix * pos;
;		gl_Position = projMatrix * positionView;
;
;		if (UBOOL_TEST(shadow._active)) {
;			Color = vec4(shadow._color, 1.0);
;		} else {
;			Color = color;
;		}
;
;		if (UBOOL_TEST(textured)) {
;			Texcoord = vec2(0.0, 1.0) + (texcoord / texScale);
;		} else {
;			Texcoord = vec2(0.0, 0.0);
;		}
;	}

; NOTES:
;	- "lightsEnabled" is not actually used
;	- Input vector "normal" is passed to the shader as part of the VBO, but isn't used here
;	- Optimize out input vector "color"; it is always (1.0, 1.0, 1.0, 1.0)
;	- Attenuations are not needed in this shader
;	- Shuffle around code to reduce stalling


; Constants
.constf myConst(0.0, 1.0, 2.0, 0.0)
.alias       ZEROS	 myConst.xxxx
.alias        ONES	 myConst.yyyy
.alias    ZERO_ONE	 myConst.xyxy


; Inputs
.alias    inPos		v0		; in vec3 position
.alias inTcoord		v1		; in vec2 texcoord


; Uniforms
.fvec modelMatrix[4]		; mat4 modelMatrix
.fvec  viewMatrix[4]		; mat4  viewMatrix
.fvec  projMatrix[4]		; mat4  projMatrix
.fvec extraMatrix[4]		; mat4 extraMatrix
.fvec    texScale			; vec2    texScale

.fvec bool_textured			; UBOOL textured
.alias textured		bool_textured.x

.fvec shadowActive		; UBOOL shadow._active
.fvec shadowColor		;  vec3 shadow._color
.fvec shadowLight		;  vec3 shadow._light
.fvec shadowPoint		;  vec3 shadow._point
.fvec shadowNormal		;  vec3 shadow._normal
.alias shadowOn		shadowActive.x


; Outputs
.out outPos		pos		; gl_Position
.out outTcoord	tcoord0	; out vec2 Texcoord
.out outColor	clr		; out vec4 Color


; Register Aliases
.alias TMP_0			r0
.alias TMP_1			r1
.alias TMP_2			r2
.alias vec4_pos			r3		;  vec4 position
.alias vec3_shPo		r4.xyz	;  vec3 shadowPoint, moved to temp register
.alias vec3_shNo		r5.xyz	;  vec3 shadowNormal, moved to temp register
.alias vec3_shLi		r6.xyz	;  vec3 shadowLight, moved to temp register
.alias vec3_L			r7.xyz	;  vec3 l
.alias flot_D			r7.w	; float d
.alias vec4_posView		r4		;  vec4 positionView


; Main
.entry main
.proc main
	; TMP_0 = vec4(inPos, 1.0);
	mov TMP_0.xyz,		inPos.xyz
	mov TMP_0.w,		ONES

	; Prepare in TMP_1 for comparison operation
	mov TMP_1.x,		shadowOn
	mov TMP_1.y,		textured
	mov TMP_1.zw,		ONES

	; extraVecPos (TMP_2, vec4) = extraMatrix (mat4) * TMP_0 (vec4);
	dp4 TMP_2.x,		extraMatrix[0],		TMP_0
	dp4 TMP_2.y,		extraMatrix[1],		TMP_0
	dp4 TMP_2.z,		extraMatrix[2],		TMP_0
	dp4 TMP_2.w,		extraMatrix[3],		TMP_0

	; Set cmp.x and cmp.y with "shadowOn == 1.0"
	;	and "textured == 1.0", respectively.
	cmp TMP_1.xy,		eq, eq,			TMP_1.zw

	; vec4_pos = modelMatrix (mat4) * extraVec (vec4);
	dp4 vec4_pos.x,		modelMatrix[0],		TMP_2
	dp4 vec4_pos.y,		modelMatrix[1],		TMP_2
	dp4 vec4_pos.z,		modelMatrix[2],		TMP_2
	dp4 vec4_pos.w,		modelMatrix[3],		TMP_2

	; if (shadowOn)
	ifc cmp.x
		rcp TMP_1,			vec4_pos.w													; TMP_1        = (1/vec4_pos.w x4)
		mov vec3_shPo,		shadowPoint.xyz												; vec3_shPo    = shadowPoint(xyz)
		mov vec3_shNo,		shadowNormal.xyz											; vec3_shNo    = shadowNormal(xyz)
		mov vec3_shLi,		shadowLight.xyz												; vec3_shLi    = shadowLight(xyz)
		mul vec4_pos,		vec4_pos,			 TMP_1									; vec4_pos    *= TMP_1 (1/vec4_pos.w x4)
		add TMP_2.xyz,		vec3_shPo,			-vec3_shLi								; TMP_2.xyz    = vec3_shPo - vec3_shLi
		add vec3_L,			vec4_pos.xyz,		-vec3_shLi								; vec3_L       = vec4_pos  - vec3_shLi
		dp3 flot_D,			TMP_2.xyz,			 vec3_shNo								; flot_D       = dp3(TMP_2.xyz, vec3_shNo)
		dp3 TMP_1.w,		vec3_L,				 vec3_shNo								; TMP_1.w      = dp3(vec3_L,    vec3_shNo)
		rcp TMP_2.w,		TMP_1.w														; TMP_2.w      = 1 / TMP_1.w
		mul flot_D,			flot_D,				 TMP_2.w								; flot_D      *= TMP_2.w
		mov vec4_pos.w,		ONES														; vec4_pos.w   = 1.0
		mad vec4_pos.xyz,	vec3_L,				 flot_D,			vec3_shLi			; vec4_pos.xyz = vec3_L * flot_D(www) + vec3_shLi
	.end

	; positionView = viewMatrix (mat4) * vec4_pos
	dp4 vec4_posView.x,	viewMatrix[0],		vec4_pos
	dp4 vec4_posView.y,	viewMatrix[1],		vec4_pos
	dp4 vec4_posView.z,	viewMatrix[2],		vec4_pos
	dp4 vec4_posView.w,	viewMatrix[3],		vec4_pos

	; outPos = projMatrix * positionView;
	dp4 outPos.x,		projMatrix[0],		vec4_posView
	dp4 outPos.y,		projMatrix[1],		vec4_posView
	dp4 outPos.z,		projMatrix[2],		vec4_posView
	dp4 outPos.w,		projMatrix[3],		vec4_posView

	; if (shadowOn)
	ifc cmp.x
		; outColor.rgb = shadowColor;
		; outColor.a = 1.0;
		mov outColor.rgb,	shadowColor.rgb
		mov outColor.a,		ONES
	.else
		; outColor = (1.0, 1.0, 1.0, 1.0);
		mov outColor,		ONES
	.end

	; if (textured)
	ifc cmp.y
		; outTcoord = vec2(0.0, 1.0) + (inTcoord (vec2) / texScale (vec2));
		rcp TMP_0.x,		texScale.x
		mov TMP_1.xy,		inTcoord.xy
		rcp TMP_0.y,		texScale.y
		mad outTcoord.xy,	TMP_0.xy,			TMP_1.xy,			ZERO_ONE.xy
	.else
		; outTcoord = vec2(0.0, 0.0)
		mov outTcoord.xy,	ZEROS
	.end

	end
.end
