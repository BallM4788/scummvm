; actorlights shader for Escape from Monkey Island in SCUMMVM

; ORIGINAL GLSL CODE
;	in vec3 position;
;	in vec2 texcoord;
;	in vec4 color;
;	in vec3 normal;
;
;	uniform highp mat4 modelMatrix;
;	uniform highp mat4 viewMatrix;
;	uniform highp mat4 projMatrix;
;	uniform highp mat4 extraMatrix;
;	uniform highp mat4 normalMatrix;
;	uniform highp vec3 cameraPos;
;	uniform UBOOL textured;
;	uniform UBOOL useVertexAlpha;
;	uniform vec4 uniformColor;
;	uniform UBOOL hasAmbient;
;
;	const int maxLights = 8;
;	uniform vec4 lightsPosition[maxLights];
;	uniform vec4 lightsDirection[maxLights];
;	uniform vec4 lightsColor[maxLights];
;	uniform vec4 lightsParams[maxLights];
;
;	struct shadow_info {
;		UBOOL _active;
;		vec3 _color;
;		vec3 _light;
;		vec3 _point;
;		vec3 _normal;
;	};
;
;	uniform shadow_info shadow;
;
;	out vec2 Texcoord;
;	out vec4 Color;
;
;	void main() {
;		vec4 pos = vec4(position, 1.0);
;		pos = modelMatrix * pos;
;
;		// See http://en.wikipedia.org/wiki/Line-plane_intersection
;		if (UBOOL_TEST(shadow._active)) {
;			pos /= pos.w;
;			vec3 l = pos.xyz - shadow._light;
;			float d = dot(shadow._point - shadow._light, shadow._normal) / dot(l, shadow._normal);
;			vec3 p = shadow._light + d * l;
;			pos = vec4(p, 1.0);
;		}
;
;		pos -= vec4(cameraPos * pos.w, 0.0);
;		pos = viewMatrix * pos;
;		pos /= pos.w;
;		pos.z *= -1.0;
;
;		vec4 projectedPos = projMatrix * pos;
;
;		gl_Position = projectedPos;
;
;		if (UBOOL_TEST(shadow._active)) {
;			Color = vec4(shadow._color, 1.0);
;		} else {
;			Color = color;
;		}
;		if (!UBOOL_TEST(useVertexAlpha))
;			Color.a = 1.0;
;		Color *= uniformColor;
;		if (UBOOL_TEST(textured)) {
;			Texcoord = texcoord;
;		} else {
;			Texcoord = vec2(0.0, 0.0);
;		}
;
;		vec3 light = vec3(0.0, 0.0, 0.0);
;		vec3 normalEye = normalize((normalMatrix * vec4(normal, 1.0)).xyz);
;
;		for (int i = 0; i < maxLights; ++i) {
;			float intensity = lightsColor[i].w;
;			float light_type = lightsPosition[i].w;
;			if (light_type >= 0.0) { // Not ambient
;				vec3 vertexToLight;
;				if (light_type > 0.0) { // positional light
;					float falloffNear = lightsParams[i].x;
;					float falloffFar = max(falloffNear, lightsParams[i].y);
;					vertexToLight = lightsPosition[i].xyz - pos.xyz;
;					float dist = length(vertexToLight);
;					if (falloffFar == falloffNear) {
;						intensity = 0.0;
;					} else {
;						intensity *= clamp(1.0 - (dist - falloffNear) / (falloffFar - falloffNear), 0.0, 1.0);
;					}
;					if (lightsDirection[i].w > -1.0) { // Spotlight
;						// See DirectX spotlight documentation
;						float cosAngle = -dot(normalize(vertexToLight), normalize(lightsDirection[i].xyz)); // rho
;						float cosPenumbra = clamp(lightsParams[i].w, 0.0, 1.0); // cos(theta / 2)
;						float cosUmbra = clamp(lightsParams[i].z, 0.0, cosPenumbra); // cos(phi / 2)
;						if (cosAngle <= cosPenumbra) {
;							if (cosAngle < cosUmbra || cosPenumbra == cosUmbra) {
;								intensity = 0.0;
;							} else {
;								intensity *= (cosAngle - cosUmbra) / (cosPenumbra - cosUmbra);
;							}
;						}
;					}
;				} else { // directional light
;					vertexToLight = -lightsPosition[i].xyz;
;				}
;				intensity *= max(0.0, dot(normalEye, normalize(vertexToLight)));
;			}
;			light += lightsColor[i].xyz * intensity;
;		}
;
;		if (!UBOOL_TEST(hasAmbient))
;			light += vec3(0.5, 0.5, 0.5);
;		light /= max(1.0, max(max(light.x, light.y), light.z));
;		Color *= vec4(light, 1.0);
;	}

; NOTES:


; Constants
.constf myConst(0.0, 1.0, 2.0, 0.5)
.alias       ZEROS	 myConst.xxxx
.alias        ONES	 myConst.yyyy
.alias     NEGONES	-myConst.yyyy
.alias    ZERO_ONE	 myConst.xyxy
.alias    ONE_HALF	 myConst.wwww

; end index = 7, start index = 0, step = 1 (loops 8 times)
.consti	loopParams(7, 0, 1, 0)


; Inputs
.alias    inPos		v0		; in vec3 position
.alias inTcoord		v1		; in vec2 texcoord
.alias  inColor		v2		; in vec4 color
.alias inNormal		v3		; in vec3 normal
; TODO: CREATE INPUT FOR LOCAL ALPHA


; Uniforms
.fvec  modelMatrix[4]		; mat4  modelMatrix
.fvec   viewMatrix[4]		; mat4   viewMatrix
.fvec   projMatrix[4]		; mat4   projMatrix
																						;.fvec  extraMatrix[4]		; mat4  extraMatrix
.fvec normalMatrix[4]		; mat4 normalMatrix
.fvec    cameraPos			; vec3    cameraPos
.fvec uniformColor			; vec4 uniformColor

.fvec bool_textured			; UBOOL textured
.fvec bool_useVtxAl			; UBOOL useVertexAlpha
.fvec bool_hasAmbi			; UBOOL hasAmbient
.alias textured		bool_textured.x
.alias useVtxAlpha	bool_useVtxAl.x
.alias hasAmbient	bool_hasAmbi.x

						; (maxLights = 8)
.fvec lightsPos[8]		; vec4 lightsPosition[maxLights]
.fvec lightsDir[8]		; vec4 lightsDirection[maxLights]
.fvec lightsClr[8]		; vec4 lightsColor[maxLights]
.fvec lightsPar[8]		; vec4 lightsParams[maxLights]

.fvec shadowActive		; UBOOL shadow._active
.fvec shadowColor		;  vec3 shadow._color
.fvec shadowLight		;  vec3 shadow._light
.fvec shadowPoint		;  vec3 shadow._point
.fvec shadowNormal		;  vec3 shadow._normal
.alias shadowOn		shadowActive.x


; Outputs
.out outPos		pos		; gl_Position
.out outTcoord	tcoord0	; out vec2 Texcoord
.out outColor	clr		; out vec4 Color


; Register Aliases
.alias TMP_0			r0
.alias TMP_1			r1
.alias TMP_2			r2
.alias vec4_pos			r3		;  vec4 pos																		THIS IS KEPT, UNLIKE IN GRIM FANDANGO
.alias vec3_shPo		r4.xyz	;  vec3 shadowPoint, moved to temp register
.alias vec3_shNo		r5.xyz	;  vec3 shadowNormal, moved to temp register
.alias vec3_shLi		r6.xyz	;  vec3 shadowLight, moved to temp register
.alias vec3_L			r7.xyz	;  vec3 l
.alias flot_D			r7.w	; float d
.alias tmpColor			r4		; Since each output register component must be written to EXACTLY ONCE,
								;	modify the output color here before writing to outColor.
.alias vec3_light		r5.xyz	;  vec3 light
.alias flot_intens		r5.w	; float intensity
.alias vec3_nrmEye		r6.xyz	;  vec3 normalEye
.alias flot_liType		r6.w	; float light_type
.alias vec3_vtxToLi		r7.xyz	;  vec3 vertexToLight
.alias flot_foNear		r8.x	; float falloffNear
.alias flot_foFar		r8.y	; float falloffFar
.alias flot_cosPenum	r9.x	; float cosPenumbra
.alias flot_cosUmbra	r9.y	; float cosUmbra
.alias flot_cosAngle	r9.z	; float cosAngle

.alias FUNC_IN			r14		; Register where function inputs are placed.
.alias FUNC_OUT			r15		; Register where function outputs can be found.


; Main
.entry main
.proc main
	; TMP_0 = vec4(inPos, 1.0);
	mov TMP_0.xyz,		inPos.xyz
	mov TMP_0.w,		ONES

	; TMP_1 = vec4(inNormal, 1.0);
	mov TMP_1.xyz,		inNormal.xyz
	mov TMP_1.w,		ONES

	; Prepare in TMP_2 for comparison operation
	mov TMP_2.x,		shadowOn
	mov TMP_2.y,		textured

	; vec4_pos = modelMatrix (mat4) * TMP_0 (vec4);
	dp4 vec4_pos.x,		modelMatrix[0],		TMP_0
	dp4 vec4_pos.y,		modelMatrix[1],		TMP_0
	dp4 vec4_pos.z,		modelMatrix[2],		TMP_0
	dp4 vec4_pos.w,		modelMatrix[3],		TMP_0										;	vec4_pos     occupied;	TMP_0        no longer needed

	; normalVec (vec4) = normalMatrix (mat4) * TMP_1 (vec4);
	dp4 TMP_0.x,		modelMatrix[0],		TMP_1
	dp4 TMP_0.y,		modelMatrix[1],		TMP_1
	dp4 TMP_0.z,		modelMatrix[2],		TMP_1
	dp4 TMP_0.w,		modelMatrix[3],		TMP_1										;	TMP_0        occupied;	TMP_1        no longer needed

	; Set cmp.x and cmp.y with "shadowOn == 1.0"
	;	and "textured == 1.0", respectively.
	cmp ONES,			eq, eq,				TMP_2.xy									;							TMP_2        no longer needed

; TMP_0:       OCCUPIED (normalVec)
; TMP_1:     UNOCCUPIED
; TMP_2:     UNOCCUPIED
; vec4_pos:    OCCUPIED (r3)
; outPos:     UNWRITTEN
; outTcoord:  UNWRITTEN
; outColor:   UNWRITTEN

	; if (shadowOn)
	ifc cmp.x
		rcp TMP_1,			vec4_pos.w													; TMP_1        = (1/vec4_pos.w x4)
		mov vec3_shPo,		shadowPoint.xyz												; vec3_shPo    = shadowPoint(xyz)
		mov vec3_shNo,		shadowNormal.xyz											; vec3_shNo    = shadowNormal(xyz)
		mov vec3_shLi,		shadowLight.xyz												; vec3_shLi    = shadowLight(xyz)
		mul vec4_pos,		vec4_pos,			 TMP_1									; vec4_pos    *= TMP_1 (1/vec4_pos.w x4)
		add TMP_2.xyz,		vec3_shPo,			-vec3_shLi								; TMP_2.xyz    = vec3_shPo - vec3_shLi
		add vec3_L,			vec4_pos.xyz,		-vec3_shLi								; vec3_L       = vec4_pos  - vec3_shLi
		dp3 flot_D,			TMP_2.xyz,			 vec3_shNo								; flot_D       = dp3(TMP_2.xyz, vec3_shNo)
		dp3 TMP_1.w,		vec3_L,				 vec3_shNo								; TMP_1.w      = dp3(vec3_L,    vec3_shNo)
		rcp TMP_2.w,		TMP_1.w														; TMP_2.w      = 1 / TMP_1.w
		mul flot_D,			flot_D,				 TMP_2.w								; flot_D      *= TMP_2.w
		mov vec4_pos.w,		ONES														; vec4_pos.w   = 1.0
		mad vec4_pos.xyz,	vec3_L,				 flot_D,			vec3_shLi			; vec4_pos.xyz = vec3_L * flot_D(www) + vec3_shLi
	.end

	; vec3_nrmEye = normalize(normalVec.xyz);
	mov FUNC_IN.xyz,	TMP_0.xyz														;							TMP_0        no longer needed
	call normalize
	mov vec3_nrmEye,	FUNC_OUT.xyz													;	vec3_nrmEye  occupied;

	; vec4_pos -= vec4(cameraPos * vec4_pos.w, 0.0);
	mov TMP_0.w,		ZEROS
	mul TMP_0.xyz,		cameraPos.xyz,		 vec4_pos.w
	add vec4_pos,		vec4_pos,			-TMP_0

	; TMP_0 (vec4) = viewMatrix (mat4) * vec4_pos;
	dp4 TMP_0.x,		viewMatrix[0],		vec4_pos
	dp4 TMP_0.y,		viewMatrix[1],		vec4_pos
	dp4 TMP_0.z,		viewMatrix[2],		vec4_pos
	dp4 TMP_0.w,		viewMatrix[3],		vec4_pos									;	TMP_0        occupied;

	; vec4_pos = TMP_0 / TMP_0.w;
	rcp TMP_1,			TMP_0.w
	mul vec4_pos,		TMP_0,				TMP_1										;							TMP_0        no longer needed

	; vec4_pos.z *= -1.0;
	mul vec4_pos.z,		NEGONES,			vec4_pos.z

	; outPos = projMatrix (mat4) * vec4_pos;
	dp4 outPos.x,		projMatrix[0],		vec4_pos
	dp4 outPos.y,		projMatrix[1],		vec4_pos
	dp4 outPos.z,		projMatrix[2],		vec4_pos
	dp4 outPos.w,		projMatrix[3],		vec4_pos									;	outPos        written;	vec4_pos         STILL NEEDED

; TMP_0:        UNOCCUPIED
; TMP_1:        UNOCCUPIED
; TMP_2:        UNOCCUPIED
; vec4_pos:       OCCUPIED (r3)
; vec3_shPo:          DONE (r4.xyz)
; vec3_shNo:          DONE (r5.xyz)
; vec3_shLi:          DONE (r6.xyz)
; vec3_L:             DONE (r7.xyz)
; flot_D:             DONE (r7.w)
; vec3_nrmEye:    OCCUPIED (r6.xyz)
; outPos:          WRITTEN
; outTcoord:     UNWRITTEN
; outColor:      UNWRITTEN

	; if (shadowOn)
	ifc cmp.x
		; tmpColor.rgb = shadowColor;
		; tmpColor.a = 1.0;
		mov tmpColor.rgb,	shadowColor.rgb
		mov tmpColor.a,		ONES
	.else
		; tmpColor = (1.0, 1.0, 1.0, 1.0);
		mov tmpColor,		ONES
	.end																				;	tmpColor     occupied;

	; if (textured)
	ifc cmp.y
		; outTcoord = inTcoord;
		mov outTcoord,		inTcoord
	.else
		; outTcoord = vec2(0.0, 0.0)
		mov outTcoord,		ZEROS
	.end																				;	outTcoord     written;

	; if (!useVtxAlpha)
	mov TMP_0.x,		ONES
	cmp useVtxAlpha,			eq, eq,				TMP_0.x
	ifc !cmp.x
		; tmpColor.a = 1.0;
		mov tmpColor.a,		ONES
	.end

	; tmpColor *= uniformColor;
	mul tmpColor,		uniformColor,		tmpColor

	; vec3_light = vec3(0.0, 0.0, 0.0);
	mov vec3_light,		ZEROS															;	vec3_light   occupied;

	; for (int i = 0; i < maxLights; ++i)
	for loopParams
		; flot_intens = lightsClr[i].w;
		; flot_liType = lightsPos[i].w;
		mov flot_intens,	lightsClr[aL].w												;	flot_intens  occupied;
		mov flot_liType,	lightsPos[aL].w												;	flot_liType  occupied;

		; Set cmp.x and cmp.y with "flot_liType >= 0.0"
		;	 and "flot_liType > 0.0", respectively.
		mov TMP_0.xy,		ZEROS
		cmp flot_liType,	ge, gt,				TMP_0.xy

		; if (flot_liType >= 0.0) [light isn't ambient]
		ifc cmp.x
			; vec3_vtxToLi = lightsPos[i].xyz;
			mov vec3_vtxToLi,	ZEROS													;	vec3_vtxToLi cleared;

			; if (flot_liType > 0.0) [positional light]
			ifc cmp.y
				; flot_foNear = lightsPar[i].x;
				; flot_foFar  = max(flot_foNear, lightsPar[i].y);
				mov flot_foNear,	lightsPar[aL].x
				max flot_foFar,		lightsPar[aL].y,	 flot_foNear

				; vec3_vtxToLi = lightsPos[i].xyz - vec4_pos.xyz
				add vec3_vtxToLi,	lightsPos[aL].xyz,	 -vec4_pos.xyz

				; if (flot_foNear == flot_foFar)
				cmp flot_foNear,	eq, eq,				 flot_foFar
				ifc cmp.x
					; intensity = 0.0;
					mov flot_intens,	ZEROS
				.else
					; TMP_0.x = length(vertexToLight);
					mul TMP_0.xyz,		vec3_vtxToLi,		 vec3_vtxToLi
					add TMP_0.x,		TMP_0.x,			 TMP_0.y
					add TMP_0.x,		TMP_0.x,			 TMP_0.z
					rsq TMP_1.x,		TMP_0.x
					mul TMP_0.x,		TMP_0.x,			 TMP_1.x

					; flot_intens *= clamp(1.0 - (TMP_0.x - flot_foNear) / (flot_foFar - flot_foNear), 0.0, 1.0);
					mov TMP_1.x,		TMP_0.x
					mov TMP_1.y,		flot_foFar
					add TMP_1.xy,		TMP_1.xy,			-flot_foNear
					rcp TMP_2.x,		TMP_1.y
					mul TMP_0.x,		TMP_1.x,			 TMP_2.x
					add FUNC_IN.x,		ONES,				-TMP_0.x
					mov FUNC_IN.yz,		ZERO_ONE
					call clamp
					mul flot_intens,	flot_intens,		 FUNC_OUT.x
				.end

				; Perform spotlight test.
				mov TMP_1.x,			NEGONES
				cmp lightsDir[aL].w,	gt, gt,			 TMP_1.x

				; if (lightsDir[i].w > -1.0)
				ifc cmp.x
					; flot_cosPenum = clamp(lightsPar[i].w, 0.0, 1.0); // cos(theta / 2)
					mov FUNC_IN.xz,		 ZERO_ONE
					mov FUNC_IN.y,		 lightsPar[aL].w
					call clamp
					mov flot_cosPenum,	 FUNC_OUT.x										;	flot_cosPenum occupied;

					; flot_cosUmbra = clamp(lightsPar[i].z, 0.0, flot_cosPenum); // cos(phi / 2)
					mov FUNC_IN.x,		 ZEROS
					mov FUNC_IN.y,		 lightsPar[aL].z
					mov FUNC_IN.z,		 flot_cosPenum
					call clamp
					mov flot_cosUmbra,	 FUNC_OUT.x										;	flot_cosUmbra occupied;

					; flot_cosAngle = -dp3(normalize(vec3_vtxToLi), normalize(lightsDir[i].xyz)); // rho
					mov FUNC_IN.xyz,	 vec3_vtxToLi
					call normalize
					mov TMP_0.xyz,		 FUNC_OUT.xyz									;	TMP_0.xyz    occupied;
					mov FUNC_IN.xyz,	 lightsDir[aL].xyz
					call normalize
					mov TMP_1.xyz,		 FUNC_OUT.xyz									;	TMP_1.xyz    occupied;
					dp3 TMP_2.x,		 TMP_1.xyz,			TMP_0.xyz					;	TMP_2.x      occupied;	TMP_0,1      no longer needed
					mov flot_cosAngle,	-TMP_2.x										;	flot_cosAngle occupied;	TMP_2        no longer needed

					; if (flot_cosAngle <= flot_cosPenum)
					cmp flot_cosAngle,	 le, le,			flot_cosPenum

					ifc cmp.x
						; if (cosAngle < cosUmbra || cosPenumbra == cosUmbra)
						mov TMP_0.x,		flot_cosAngle
						mov TMP_0.z,		flot_cosPenum
						mov TMP_0.yw,		flot_cosUmbra
						cmp TMP_0.xy,		gt, eq,				TMP_0.zw

						ifc cmp.x || cmp.y
							mov flot_intens,	ZEROS
						.else
							; flot_intens *= (flot_cosAngle - flot_cosUmbra) / (flot_cosPenum - flot_cosUmbra);
							add TMP_0.x,		flot_cosAngle,		-flot_cosUmbra		;	TMP_0.x      occupied;
							add TMP_1.x,		flot_cosPenum,		-flot_cosUmbra		;	TMP_1.x      occupied;
							rcp TMP_2.x,		TMP_1.x									;	TMP_2.x      occupied;	TMP_1        no longer needed
							mul TMP_0.x,		TMP_0.x,			 TMP_2.x			;							TMP_2        no longer needed
							mul flot_intens,	flot_intens,		 TMP_0.x			;							TMP_0        no longer needed
						.end
					nop
					.end
				nop
				.end
			nop
			.else
				; vec3_vtxToLi = -lightsPos[i].xyz;
				mov vec3_vtxToLi,	-lightsPos[aL].xyz
			.end

			; flot_intens *= max(0.0, dp3(vec3_nrmEye, normalize(vec3_vtxToLi)));
			mov FUNC_IN.xyz,	 vec3_vtxToLi
			call normalize
			mov TMP_0.xyz,		 FUNC_OUT.xyz											;	TMP_0.xyz    occupied;
			dp3 TMP_1.x,		 vec3_nrmEye,		TMP_0.xyz							;	TMP_1.x      occupied;	TMP_0        no longer needed
			max TMP_0.x,		 ZEROS,				TMP_1.x								;	TMP_0.x      occupied;	TMP_1        no longer needed
			mul flot_intens,	 flot_intens,		TMP_0.x								;							TMP_0        no longer needed
		.end

		; vec3_light += lightsClr[i].xyz * flot_intens;
		mul TMP_0.xyz,		lightsClr[aL].xyz,	flot_intens
		add vec3_light,		TMP_0.xyz,			vec3_light
	.end

	; if (hasAmbient)
	mov TMP_0.x,		ONES
	cmp hasAmbient,		eq, eq,				TMP_0.x
	ifc cmp.x
		add vec3_light,		ONE_HALF,			vec3_light
	.end

	; vec3_light /= max(1.0, max(max(vec3_light.x, vec3_light.y), vec3_light.z))
	max TMP_0.x,		vec3_light.x,		vec3_light.y
	max TMP_0.x,		TMP_0.x,			vec3_light.z
	max TMP_0.x,		ONES,				TMP_0.x
	rcp TMP_0.x,		TMP_0.x
	mul vec3_light,		vec3_light,			TMP_0.x

	; tmpColor *= vec4(vec3_light, 1.0)
	mul tmpColor.rgb,	tmpColor.rgb,		vec3_light
	; outColor = tmpColor
	mov outColor,		tmpColor														;	outColor      written;

	end
.end


; Functions
.proc normalize
	dp3 FUNC_OUT.w,		FUNC_IN.xyz,		FUNC_IN.xyz
	rsq FUNC_OUT.w,		FUNC_OUT.w
	mul FUNC_OUT.xyz,	FUNC_IN.xyz,		FUNC_OUT.w
.end

.proc clamp
	max FUNC_OUT.x,		FUNC_IN.x,			FUNC_IN.y
	min FUNC_OUT.x,		FUNC_OUT.x,			FUNC_IN.z
.end
